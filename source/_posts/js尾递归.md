---
title: js尾递归
date: 2017-12-04
categories: js
tags: js，js基础
toc: true
---
# 前言

在有些语言中，执行尾递归时将会被自动识别，继而在运行时优化成循环的形式，这种优化逻辑大多是Tail Call Optimisation尾部调用优化，（尾调用概念就是在函数最后一步调用其他函数，尾递归即在最后一步调用自身）

# 递归

使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。

```js
//使用递归将求和过程复杂化
function sum(x, y) {
    if (y > 0) {
      return sum(x + 1, y - 1);
    } else {
      return x;
    }
}

sum(1, 10); // => 11

```

当运算规模较小时，这种方式可以正常输出结果，可是当把参数变为sum(1,100000)时，就会造成“栈溢出错误”浏览器就会报错`Uncaught RangeError: Maximum call stack size exceeded`



# 尾递归

```
尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。
```

# 尾调用及优化

```
尾调用之所以与其他调用不同，就在于它的特殊的调用位置。
```
```
尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。
```
```js
function f() {
  let m = 1;
  let n = 2;
  return g(m + n);
}
f();

// 等同于
function f() {
  return g(3);
}
f();

// 等同于
g(3);
```
上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f() 的调用记录，只保留 g(3) 的调用记录。
这就叫做"尾调用优化"（Tail call optimization），即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是"尾调用优化"的意义。

# 尾调用优化


解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。

```js
function sum(x, y) {
    function recur(a, b) {
        if (b > 0) {
            return recur(a + 1, b - 1);
        } else {
            return a;
        }
    }
//尾递归即在程序尾部调用自身，注意这里没有其他的运算
    return recur(x, y);
}

sum(1, 10); // => 11
```
以上这种写法在有TCO机制的语言中将在执行时内部优化成循环形式而不会产生“栈溢出”错误，注意，在当前版本的JS中以上写法是无效的！`因为在当前普遍的JS版本（ES5）中并没有这个优化机制。`但是在`ES6中已经实现了这个机制` 在当前普遍的JS版本中我们只能使用替代方案


> 这里插一句：使用Babel可以在当前JS版本中用ES6的特性（Babel可以将使用ES6特性编程的代码转换成兼容的ES5形式），将原sum()函数输入Babel的编译器后，确实被转换成了循环的形式，感兴趣的同学可以自己试试：
BABEL编译器转换sum()函数的结果如下（对于算法逻辑不太感兴趣的同学看到这里就差不多了，
可以直接将一些深递归放到Babel中转换下就可以了）：

```javascript
var _again = true;

  _function: while (_again) {
    var x = _x,
        y = _x2;
    _again = false;

    if (y > 0) {
      _x = x + 1;
      _x2 = y - 1;
      _again = true;
      continue _function;
    } else {
      return x;
    }   } } 
```
